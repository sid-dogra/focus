<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Focus â€” Personal Productivity</title>
  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#7C3AED">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Focus">
  <link rel="apple-touch-icon" href="icon-192.svg">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js" async defer></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'system-ui', 'sans-serif'] },
          colors: {
            research: { light: '#EDE9FE', DEFAULT: '#7C3AED', dark: '#5B21B6' },
            admin: { light: '#FEF3C7', DEFAULT: '#F59E0B', dark: '#B45309' },
            startup: { light: '#D1FAE5', DEFAULT: '#10B981', dark: '#047857' },
            personal: { light: '#FFE4E6', DEFAULT: '#F43F5E', dark: '#BE123C' },
          }
        }
      }
    }
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', system-ui, sans-serif; background: #F8FAFC; color: #1E293B; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #CBD5E1; border-radius: 3px; }
    .timeline-grid { display: grid; grid-template-columns: 60px 1fr; }
    .fade-in { animation: fadeIn 0.2s ease-out; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }
    .task-card:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
    .task-card { transition: all 0.15s ease; }
    .time-slot { min-height: 48px; border-top: 1px solid #E2E8F0; }
    .modal-overlay { backdrop-filter: blur(4px); }
    .category-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    @media (max-width: 768px) {
      .sidebar { transform: translateX(-100%); position: fixed; z-index: 50; height: 100vh; }
      .sidebar.open { transform: translateX(0); }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    // Register service worker for PWA / offline support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').then(reg => {
          console.log('SW registered:', reg.scope);
        }).catch(err => console.log('SW registration failed:', err));
      });
    }
  </script>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;

    // ===== CONSTANTS =====
    const CATEGORIES = {
      research:  { label: 'Research',  color: '#7C3AED', light: '#EDE9FE', gcalColorId: '9' },
      admin:     { label: 'Admin',     color: '#F59E0B', light: '#FEF3C7', gcalColorId: '5' },
      startup:   { label: 'Startup',   color: '#10B981', light: '#D1FAE5', gcalColorId: '10' },
      personal:  { label: 'Personal',  color: '#F43F5E', light: '#FFE4E6', gcalColorId: '6' },
    };

    const EFFORT = {
      quick:  { label: 'Quick',  minutes: 15, icon: 'âš¡' },
      medium: { label: 'Medium', minutes: 45, icon: 'ðŸ”¨' },
      deep:   { label: 'Deep',   minutes: 120, icon: 'ðŸ§ ' },
    };

    const DEFAULT_SETTINGS = {
      weekdayAvailableAfter: 17,
      weekdayAvailableUntil: 22,
      weekendAvailableAfter: 10,
      weekendAvailableUntil: 22,
      dangerZoneHours: 48,
      googleClientId: '',
      allowedEmails: ['dograsiddhant@gmail.com'],
    };

    // ===== STORAGE =====
    const storage = {
      get: (key, fallback) => { try { const v = localStorage.getItem('focus_' + key); return v ? JSON.parse(v) : fallback; } catch { return fallback; } },
      set: (key, value) => { try { localStorage.setItem('focus_' + key, JSON.stringify(value)); } catch {} },
    };

    // ===== DATE HELPERS =====
    const isWeekend = (d) => [0, 6].includes(new Date(d).getDay());
    const fmt = {
      date: (d) => new Date(d).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
      time: (d) => new Date(d).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }),
      timeShort: (h, m = 0) => { const d = new Date(); d.setHours(h, m); return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }); },
      relative: (d) => {
        const now = new Date(), target = new Date(d);
        const diff = Math.ceil((target - now) / (1000 * 60 * 60));
        if (diff < 0) return 'Overdue';
        if (diff < 24) return `${diff}h left`;
        const days = Math.ceil(diff / 24);
        return days === 1 ? 'Tomorrow' : `${days} days`;
      }
    };

    const timeToMinutes = (h, m = 0) => h * 60 + m;
    const minutesToTime = (mins) => ({ h: Math.floor(mins / 60), m: mins % 60 });
    const uid = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);

    // ===== GOOGLE CALENDAR SERVICE =====
    const GCalService = {
      _tokenClient: null,
      _accessToken: null,
      _gapiReady: false,
      _gisReady: false,

      init(clientId, onReady) {
        if (!clientId) return;
        const checkReady = () => {
          if (this._gapiReady && this._gisReady && onReady) onReady();
        };
        // Init GAPI
        if (window.gapi) {
          gapi.load('client', async () => {
            await gapi.client.init({});
            await gapi.client.load('https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest');
            this._gapiReady = true;
            checkReady();
          });
        }
        // Init GIS
        if (window.google?.accounts?.oauth2) {
          this._tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: clientId,
            scope: 'https://www.googleapis.com/auth/calendar',
            callback: (resp) => {
              if (resp.access_token) {
                this._accessToken = resp.access_token;
                gapi.client.setToken({ access_token: resp.access_token });
              }
            },
          });
          this._gisReady = true;
          checkReady();
        }
      },

      async authorize() {
        return new Promise((resolve, reject) => {
          if (!this._tokenClient) return reject('Google not initialized');
          const origCb = this._tokenClient.callback;
          this._tokenClient.callback = (resp) => {
            if (resp.error) return reject(resp.error);
            this._accessToken = resp.access_token;
            gapi.client.setToken({ access_token: resp.access_token });
            resolve(resp.access_token);
          };
          this._tokenClient.requestAccessToken({ prompt: 'consent' });
        });
      },

      isAuthorized() { return !!this._accessToken; },

      async listEvents(startDate, endDate) {
        if (!this._accessToken) throw new Error('Not authorized');
        const resp = await gapi.client.calendar.events.list({
          calendarId: 'primary',
          timeMin: new Date(startDate).toISOString(),
          timeMax: new Date(endDate).toISOString(),
          singleEvents: true,
          orderBy: 'startTime',
          maxResults: 100,
        });
        return (resp.result.items || []).map(e => ({
          id: e.id,
          title: e.summary || '(No title)',
          start: e.start.dateTime || e.start.date,
          end: e.end.dateTime || e.end.date,
          allDay: !e.start.dateTime,
          source: 'google',
        }));
      },

      async createTimeBlock(task, startDateTime, endDateTime) {
        if (!this._accessToken) throw new Error('Not authorized');
        const cat = CATEGORIES[task.category];
        const resp = await gapi.client.calendar.events.insert({
          calendarId: 'primary',
          resource: {
            summary: `[Focus] ${task.title}`,
            description: `Category: ${cat.label}\nEffort: ${EFFORT[task.effort].label}\n${task.notes || ''}`,
            start: { dateTime: new Date(startDateTime).toISOString() },
            end: { dateTime: new Date(endDateTime).toISOString() },
            colorId: cat.gcalColorId,
          },
        });
        return resp.result;
      },

      async deleteTimeBlock(eventId) {
        if (!this._accessToken) return;
        await gapi.client.calendar.events.delete({ calendarId: 'primary', eventId });
      },
    };

    // ===== SCHEDULING ENGINE =====
    function generateSchedule(tasks, calendarEvents, date, settings, eventClassifications) {
      const d = new Date(date);
      const weekend = isWeekend(d);
      const availStart = weekend ? settings.weekendAvailableAfter : settings.weekdayAvailableAfter;
      const availEnd = weekend ? settings.weekendAvailableUntil : settings.weekdayAvailableUntil;

      // Check for academic time
      const hasAcademic = calendarEvents.some(e => {
        const cls = eventClassifications[e.id] || eventClassifications[e.title?.toLowerCase()] || 'hard';
        return cls === 'academic';
      });

      let effectiveStart = availStart;
      if (hasAcademic && !weekend) effectiveStart = 13; // Academic afternoon: open from 1 PM

      // Build free windows
      const dayStart = timeToMinutes(effectiveStart);
      const dayEnd = timeToMinutes(availEnd);

      // Get hard blocks within our available window
      const hardBlocks = [];
      const softBlocks = [];
      calendarEvents.forEach(e => {
        if (e.allDay) return;
        const eStart = new Date(e.start);
        const eEnd = new Date(e.end);
        if (eStart.toDateString() !== d.toDateString()) return;

        const startMins = timeToMinutes(eStart.getHours(), eStart.getMinutes());
        const endMins = timeToMinutes(eEnd.getHours(), eEnd.getMinutes());
        const cls = eventClassifications[e.id] || eventClassifications[e.title?.toLowerCase()] || 'hard';

        if (cls === 'soft') {
          softBlocks.push({ start: Math.max(startMins, dayStart), end: Math.min(endMins, dayEnd), event: e });
        } else if (cls === 'hard' || cls === 'academic') {
          hardBlocks.push({ start: Math.max(startMins, dayStart), end: Math.min(endMins, dayEnd), event: e });
        }
      });

      hardBlocks.sort((a, b) => a.start - b.start);

      // Calculate free windows (excluding hard blocks)
      const freeWindows = [];
      let cursor = dayStart;
      for (const block of hardBlocks) {
        if (block.start > cursor) freeWindows.push({ start: cursor, end: block.start });
        cursor = Math.max(cursor, block.end);
      }
      if (cursor < dayEnd) freeWindows.push({ start: cursor, end: dayEnd });

      // Sort tasks into tiers
      const now = new Date();
      const dangerMs = settings.dangerZoneHours * 60 * 60 * 1000;
      const incompleteTasks = tasks.filter(t => t.status !== 'done');

      const urgent = incompleteTasks.filter(t => t.deadline && (new Date(t.deadline) - now) < dangerMs && (new Date(t.deadline) - now) > 0)
        .sort((a, b) => new Date(a.deadline) - new Date(b.deadline));

      const overdue = incompleteTasks.filter(t => t.deadline && (new Date(t.deadline) - now) <= 0);

      const remaining = incompleteTasks.filter(t => !urgent.includes(t) && !overdue.includes(t));
      const quick = remaining.filter(t => t.effort === 'quick').sort((a, b) => b.importance - a.importance);
      const deep = remaining.filter(t => t.effort === 'deep').sort((a, b) => {
        const aScore = a.importance * (a.deadline ? (1 + 1000 / Math.max(1, (new Date(a.deadline) - now) / 3600000)) : 1);
        const bScore = b.importance * (b.deadline ? (1 + 1000 / Math.max(1, (new Date(b.deadline) - now) / 3600000)) : 1);
        return bScore - aScore;
      });
      const medium = remaining.filter(t => t.effort === 'medium').sort((a, b) => {
        const aScore = a.importance * (a.deadline ? (1 + 1000 / Math.max(1, (new Date(a.deadline) - now) / 3600000)) : 1);
        const bScore = b.importance * (b.deadline ? (1 + 1000 / Math.max(1, (new Date(b.deadline) - now) / 3600000)) : 1);
        return bScore - aScore;
      });

      // Schedule into windows
      const scheduled = [];
      let windowsCopy = freeWindows.map(w => ({ ...w }));

      function placeTask(task) {
        const dur = EFFORT[task.effort].minutes;
        // Find best window (shortest that fits for quick/medium, longest for deep)
        let bestIdx = -1;
        if (task.effort === 'deep') {
          let maxLen = 0;
          windowsCopy.forEach((w, i) => { const len = w.end - w.start; if (len >= dur && len > maxLen) { maxLen = len; bestIdx = i; } });
        } else {
          let minLen = Infinity;
          windowsCopy.forEach((w, i) => { const len = w.end - w.start; if (len >= dur && len < minLen) { minLen = len; bestIdx = i; } });
        }

        if (bestIdx === -1) return false;
        const w = windowsCopy[bestIdx];
        const startMin = w.start;
        const endMin = startMin + dur;

        scheduled.push({
          id: uid(),
          taskId: task.id,
          task,
          startMinutes: startMin,
          endMinutes: endMin,
          type: 'task',
        });

        // Shrink window
        if (endMin >= w.end) {
          windowsCopy.splice(bestIdx, 1);
        } else {
          windowsCopy[bestIdx] = { start: endMin, end: w.end };
        }
        return true;
      }

      // Place overdue first
      overdue.forEach(t => placeTask(t));
      // Place urgent
      urgent.forEach(t => placeTask(t));
      // Place quick wins as a batch
      quick.forEach(t => placeTask(t));
      // Place deep work
      deep.forEach(t => placeTask(t));
      // Place medium
      medium.forEach(t => placeTask(t));

      // Add soft block suggestions
      softBlocks.forEach(sb => {
        const quickForSoft = quick.filter(q => !scheduled.find(s => s.taskId === q.id));
        quickForSoft.slice(0, 2).forEach(t => {
          scheduled.push({
            id: uid(),
            taskId: t.id,
            task: t,
            startMinutes: sb.start,
            endMinutes: Math.min(sb.start + EFFORT[t.effort].minutes, sb.end),
            type: 'soft-suggestion',
            softEvent: sb.event,
          });
        });
      });

      // Add calendar events to the timeline
      const eventBlocks = calendarEvents.filter(e => !e.allDay).map(e => {
        const eStart = new Date(e.start);
        const eEnd = new Date(e.end);
        if (eStart.toDateString() !== d.toDateString()) return null;
        const cls = eventClassifications[e.id] || eventClassifications[e.title?.toLowerCase()] || 'hard';
        return {
          id: e.id,
          title: e.title,
          startMinutes: timeToMinutes(eStart.getHours(), eStart.getMinutes()),
          endMinutes: timeToMinutes(eEnd.getHours(), eEnd.getMinutes()),
          type: 'event',
          classification: cls,
          event: e,
        };
      }).filter(Boolean);

      return { scheduled: [...scheduled, ...eventBlocks].sort((a, b) => a.startMinutes - b.startMinutes), freeWindows, overdue, urgent };
    }

    // ===== AUTH GATE =====
    function AuthGate({ children }) {
      const settings = storage.get('settings', DEFAULT_SETTINGS);
      const clientId = settings.googleClientId;
      const allowedEmails = settings.allowedEmails || [];
      const [user, setUser] = useState(null);
      const [denied, setDenied] = useState(false);
      const [loading, setLoading] = useState(true);
      const signInRef = useRef(null);

      // If no client ID or no allowed emails, skip auth
      const authRequired = clientId && allowedEmails.length > 0;

      useEffect(() => {
        if (!authRequired) { setLoading(false); return; }

        // Check stored session
        try {
          const stored = sessionStorage.getItem('focus_auth');
          if (stored) {
            const parsed = JSON.parse(stored);
            if (allowedEmails.map(e => e.toLowerCase()).includes(parsed.email.toLowerCase())) {
              setUser(parsed);
              setLoading(false);
              return;
            }
          }
        } catch {}

        // Wait for Google Identity Services to load
        const interval = setInterval(() => {
          if (window.google?.accounts?.id) {
            clearInterval(interval);
            google.accounts.id.initialize({
              client_id: clientId,
              callback: (response) => {
                try {
                  const payload = JSON.parse(atob(response.credential.split('.')[1]));
                  if (allowedEmails.map(e => e.toLowerCase()).includes(payload.email.toLowerCase())) {
                    const userData = { email: payload.email, name: payload.name, picture: payload.picture };
                    sessionStorage.setItem('focus_auth', JSON.stringify(userData));
                    setUser(userData);
                    setDenied(false);
                  } else {
                    setDenied(true);
                    setUser({ email: payload.email });
                  }
                } catch (err) { setDenied(true); }
              },
              auto_select: true,
            });
            // Render the Google Sign-In button
            if (signInRef.current) {
              google.accounts.id.renderButton(signInRef.current, {
                theme: 'outline', size: 'large', width: 280, text: 'signin_with',
              });
            }
            // Also try One Tap auto prompt
            google.accounts.id.prompt();
            setLoading(false);
          }
        }, 300);

        const timeout = setTimeout(() => { clearInterval(interval); setLoading(false); }, 8000);
        return () => { clearInterval(interval); clearTimeout(timeout); };
      }, []);

      if (!authRequired) return children;

      if (loading) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="text-center">
              <div className="w-12 h-12 bg-violet-600 rounded-xl flex items-center justify-center text-white text-xl font-bold mx-auto mb-4">F</div>
              <div className="text-sm text-gray-400">Loading...</div>
            </div>
          </div>
        );
      }

      if (denied) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
            <div className="bg-white rounded-2xl border border-gray-200 shadow-sm p-8 max-w-sm text-center">
              <div className="w-12 h-12 bg-red-100 rounded-xl flex items-center justify-center text-red-500 text-xl mx-auto mb-4">!</div>
              <h2 className="text-lg font-semibold text-gray-900 mb-2">Access Denied</h2>
              <p className="text-sm text-gray-500 mb-4">
                {user?.email || 'Your account'} is not authorized to use this app.
              </p>
              <button onClick={() => { sessionStorage.removeItem('focus_auth'); setDenied(false); setUser(null); }}
                className="px-4 py-2 text-sm font-medium text-violet-600 hover:bg-violet-50 rounded-lg">
                Try another account
              </button>
            </div>
          </div>
        );
      }

      if (user && !denied) return children;

      // Sign-in screen
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
          <div className="bg-white rounded-2xl border border-gray-200 shadow-sm p-8 max-w-sm text-center">
            <div className="w-14 h-14 bg-violet-600 rounded-xl flex items-center justify-center text-white text-2xl font-bold mx-auto mb-4">F</div>
            <h1 className="text-xl font-bold text-gray-900 mb-1">Focus</h1>
            <p className="text-sm text-gray-500 mb-6">Sign in to access your tasks</p>
            <div ref={signInRef} className="flex justify-center mb-4" />
            <p className="text-xs text-gray-400">Only authorized accounts can access this app.</p>
          </div>
        </div>
      );
    }

    // ===== MAIN APP =====
    function App() {
      const [tasks, setTasks] = useState(() => storage.get('tasks', []));
      const [settings, setSettings] = useState(() => storage.get('settings', DEFAULT_SETTINGS));
      const [eventClassifications, setEventClassifications] = useState(() => storage.get('eventClassifications', {}));
      const [view, setView] = useState('today');
      const [showTaskModal, setShowTaskModal] = useState(false);
      const [editingTask, setEditingTask] = useState(null);
      const [calendarEvents, setCalendarEvents] = useState([]);
      const [gcalConnected, setGcalConnected] = useState(false);
      const [gcalLoading, setGcalLoading] = useState(false);
      const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);
      const [sidebarOpen, setSidebarOpen] = useState(false);
      const [schedule, setSchedule] = useState(null);
      const [notification, setNotification] = useState(null);

      // Persist
      useEffect(() => { storage.set('tasks', tasks); }, [tasks]);
      useEffect(() => { storage.set('settings', settings); }, [settings]);
      useEffect(() => { storage.set('eventClassifications', eventClassifications); }, [eventClassifications]);

      // Init Google Calendar
      useEffect(() => {
        if (settings.googleClientId) {
          const interval = setInterval(() => {
            if (window.gapi && window.google?.accounts?.oauth2) {
              clearInterval(interval);
              GCalService.init(settings.googleClientId, () => {});
            }
          }, 500);
          return () => clearInterval(interval);
        }
      }, [settings.googleClientId]);

      const notify = (msg, type = 'success') => {
        setNotification({ msg, type });
        setTimeout(() => setNotification(null), 3000);
      };

      // Task CRUD
      const addTask = (task) => {
        const newTask = { ...task, id: uid(), status: 'todo', createdAt: new Date().toISOString() };
        setTasks(prev => [newTask, ...prev]);
        notify('Task added');
      };
      const updateTask = (id, updates) => {
        setTasks(prev => prev.map(t => t.id === id ? { ...t, ...updates } : t));
      };
      const deleteTask = (id) => {
        setTasks(prev => prev.filter(t => t.id !== id));
        notify('Task deleted');
      };
      const toggleDone = (id) => {
        setTasks(prev => prev.map(t => t.id === id ? { ...t, status: t.status === 'done' ? 'todo' : 'done' } : t));
      };

      // Google Calendar
      const connectGCal = async () => {
        setGcalLoading(true);
        try {
          await GCalService.authorize();
          setGcalConnected(true);
          notify('Google Calendar connected!');
          await fetchEvents();
        } catch (err) {
          notify('Failed to connect: ' + err, 'error');
        }
        setGcalLoading(false);
      };

      const fetchEvents = async () => {
        try {
          const start = new Date(selectedDate);
          start.setDate(start.getDate() - 1);
          const end = new Date(selectedDate);
          end.setDate(end.getDate() + 8);
          const events = await GCalService.listEvents(start, end);
          setCalendarEvents(events);
        } catch (err) {
          console.error('Fetch events error:', err);
        }
      };

      useEffect(() => {
        if (gcalConnected) fetchEvents();
      }, [selectedDate, gcalConnected]);

      // Auto-schedule
      const runAutoSchedule = () => {
        const result = generateSchedule(tasks, calendarEvents, selectedDate, settings, eventClassifications);
        setSchedule(result);
        notify(`Scheduled ${result.scheduled.filter(s => s.type === 'task').length} tasks`);
      };

      // Push to Google Calendar
      const pushToGCal = async () => {
        if (!gcalConnected || !schedule) return;
        setGcalLoading(true);
        try {
          const taskBlocks = schedule.scheduled.filter(s => s.type === 'task');
          const dateBase = new Date(selectedDate);
          for (const block of taskBlocks) {
            const { h: sh, m: sm } = minutesToTime(block.startMinutes);
            const { h: eh, m: em } = minutesToTime(block.endMinutes);
            const start = new Date(dateBase); start.setHours(sh, sm, 0, 0);
            const end = new Date(dateBase); end.setHours(eh, em, 0, 0);
            await GCalService.createTimeBlock(block.task, start, end);
          }
          notify(`Pushed ${taskBlocks.length} blocks to Google Calendar!`);
          await fetchEvents();
        } catch (err) {
          notify('Failed to push: ' + err, 'error');
        }
        setGcalLoading(false);
      };

      // PWA install prompt
      const [installPrompt, setInstallPrompt] = useState(null);
      useEffect(() => {
        const handler = (e) => { e.preventDefault(); setInstallPrompt(e); };
        window.addEventListener('beforeinstallprompt', handler);
        return () => window.removeEventListener('beforeinstallprompt', handler);
      }, []);
      const handleInstall = async () => {
        if (!installPrompt) return;
        installPrompt.prompt();
        const result = await installPrompt.userChoice;
        if (result.outcome === 'accepted') { setInstallPrompt(null); notify('App installed!'); }
      };

      // Stats
      const stats = useMemo(() => {
        const done = tasks.filter(t => t.status === 'done').length;
        const total = tasks.length;
        const overdue = tasks.filter(t => t.deadline && new Date(t.deadline) < new Date() && t.status !== 'done').length;
        const upcoming = tasks.filter(t => t.deadline && t.status !== 'done')
          .sort((a, b) => new Date(a.deadline) - new Date(b.deadline)).slice(0, 3);
        return { done, total, overdue, upcoming };
      }, [tasks]);

      return (
        <div className="flex h-screen overflow-hidden">
          {/* Mobile overlay */}
          {sidebarOpen && <div className="fixed inset-0 bg-black/30 z-40 md:hidden" onClick={() => setSidebarOpen(false)} />}

          {/* Sidebar */}
          <aside className={`sidebar ${sidebarOpen ? 'open' : ''} w-64 bg-white border-r border-gray-200 flex flex-col md:relative md:translate-x-0`}>
            <div className="p-5 border-b border-gray-100">
              <h1 className="text-xl font-bold text-gray-900 flex items-center gap-2">
                <span className="w-8 h-8 bg-violet-600 rounded-lg flex items-center justify-center text-white text-sm font-bold">F</span>
                Focus
              </h1>
            </div>
            <nav className="flex-1 p-3 space-y-1">
              {[
                { id: 'today', label: 'Today', icon: 'ðŸ“…' },
                { id: 'week', label: 'This Week', icon: 'ðŸ“‹' },
                { id: 'all', label: 'All Tasks', icon: 'ðŸ“¦' },
                { id: 'settings', label: 'Settings', icon: 'âš™ï¸' },
              ].map(item => (
                <button key={item.id} onClick={() => { setView(item.id); setSidebarOpen(false); }}
                  className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-colors ${view === item.id ? 'bg-violet-50 text-violet-700' : 'text-gray-600 hover:bg-gray-50'}`}>
                  <span>{item.icon}</span> {item.label}
                </button>
              ))}
            </nav>
            <div className="p-4 border-t border-gray-100">
              {installPrompt && (
                <button onClick={handleInstall}
                  className="w-full mb-3 px-3 py-2 text-xs font-medium bg-violet-50 text-violet-700 rounded-lg hover:bg-violet-100 transition-colors">
                  Install as App
                </button>
              )}
              <div className="text-xs text-gray-400 mb-2">Completed</div>
              <div className="flex items-center gap-2">
                <div className="flex-1 bg-gray-100 rounded-full h-2">
                  <div className="bg-violet-500 h-2 rounded-full transition-all" style={{ width: `${stats.total ? (stats.done / stats.total * 100) : 0}%` }} />
                </div>
                <span className="text-xs text-gray-500 font-medium">{stats.done}/{stats.total}</span>
              </div>
              {stats.overdue > 0 && <div className="mt-2 text-xs text-red-500 font-medium">{stats.overdue} overdue</div>}
              {settings.googleClientId && (() => {
                try {
                  const authUser = JSON.parse(sessionStorage.getItem('focus_auth') || 'null');
                  if (!authUser) return null;
                  return (
                    <div className="mt-3 pt-3 border-t border-gray-100 flex items-center justify-between">
                      <span className="text-xs text-gray-400 truncate">{authUser.email}</span>
                      <button onClick={() => { sessionStorage.removeItem('focus_auth'); window.location.reload(); }}
                        className="text-xs text-gray-400 hover:text-red-500 ml-2 flex-shrink-0">Sign out</button>
                    </div>
                  );
                } catch { return null; }
              })()}
            </div>
          </aside>

          {/* Main */}
          <main className="flex-1 flex flex-col overflow-hidden">
            {/* Header */}
            <header className="bg-white border-b border-gray-200 px-4 md:px-6 py-3 flex items-center justify-between flex-shrink-0">
              <div className="flex items-center gap-3">
                <button onClick={() => setSidebarOpen(true)} className="md:hidden p-2 text-gray-500 hover:bg-gray-100 rounded-lg">
                  <svg width="20" height="20" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h14M3 10h14M3 14h14"/></svg>
                </button>
                <h2 className="text-lg font-semibold text-gray-900">
                  {view === 'today' ? fmt.date(selectedDate) : view === 'week' ? 'This Week' : view === 'all' ? 'All Tasks' : 'Settings'}
                </h2>
                {view === 'today' && (
                  <div className="flex items-center gap-1 ml-2">
                    <button onClick={() => { const d = new Date(selectedDate); d.setDate(d.getDate() - 1); setSelectedDate(d.toISOString().split('T')[0]); setSchedule(null); }}
                      className="p-1 text-gray-400 hover:text-gray-600 rounded">â€¹</button>
                    <button onClick={() => { setSelectedDate(new Date().toISOString().split('T')[0]); setSchedule(null); }}
                      className="px-2 py-0.5 text-xs font-medium text-violet-600 bg-violet-50 rounded-full hover:bg-violet-100">Today</button>
                    <button onClick={() => { const d = new Date(selectedDate); d.setDate(d.getDate() + 1); setSelectedDate(d.toISOString().split('T')[0]); setSchedule(null); }}
                      className="p-1 text-gray-400 hover:text-gray-600 rounded">â€º</button>
                  </div>
                )}
              </div>
              <div className="flex items-center gap-2">
                {view === 'today' && (
                  <>
                    <button onClick={runAutoSchedule}
                      className="px-3 py-1.5 text-sm font-medium bg-violet-600 text-white rounded-lg hover:bg-violet-700 transition-colors">
                      Plan My Day
                    </button>
                    {gcalConnected && schedule && (
                      <button onClick={pushToGCal} disabled={gcalLoading}
                        className="px-3 py-1.5 text-sm font-medium bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-colors disabled:opacity-50">
                        {gcalLoading ? '...' : 'Push to GCal'}
                      </button>
                    )}
                  </>
                )}
                <button onClick={() => { setEditingTask(null); setShowTaskModal(true); }}
                  className="px-3 py-1.5 text-sm font-medium bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors">
                  + Task
                </button>
              </div>
            </header>

            {/* Content */}
            <div className="flex-1 overflow-y-auto p-4 md:p-6">
              {view === 'today' && <TodayView tasks={tasks} schedule={schedule} calendarEvents={calendarEvents} selectedDate={selectedDate}
                settings={settings} eventClassifications={eventClassifications} toggleDone={toggleDone} onEdit={(t) => { setEditingTask(t); setShowTaskModal(true); }} />}
              {view === 'week' && <WeekView tasks={tasks} calendarEvents={calendarEvents} selectedDate={selectedDate} settings={settings}
                eventClassifications={eventClassifications} toggleDone={toggleDone} onEdit={(t) => { setEditingTask(t); setShowTaskModal(true); }} />}
              {view === 'all' && <AllTasksView tasks={tasks} toggleDone={toggleDone} deleteTask={deleteTask}
                onEdit={(t) => { setEditingTask(t); setShowTaskModal(true); }} />}
              {view === 'settings' && <SettingsView settings={settings} setSettings={setSettings} gcalConnected={gcalConnected}
                connectGCal={connectGCal} gcalLoading={gcalLoading} calendarEvents={calendarEvents}
                eventClassifications={eventClassifications} setEventClassifications={setEventClassifications} />}
            </div>
          </main>

          {/* Task Modal */}
          {showTaskModal && <TaskModal task={editingTask} onSave={(t) => { editingTask ? updateTask(editingTask.id, t) : addTask(t); setShowTaskModal(false); }}
            onClose={() => setShowTaskModal(false)} />}

          {/* Notification */}
          {notification && (
            <div className={`fixed bottom-4 right-4 px-4 py-2.5 rounded-lg text-sm font-medium shadow-lg fade-in z-50 ${notification.type === 'error' ? 'bg-red-500 text-white' : 'bg-gray-900 text-white'}`}>
              {notification.msg}
            </div>
          )}
        </div>
      );
    }

    // ===== TODAY VIEW =====
    function TodayView({ tasks, schedule, calendarEvents, selectedDate, settings, eventClassifications, toggleDone, onEdit }) {
      const incompleteTasks = tasks.filter(t => t.status !== 'done');
      const now = new Date();
      const dangerMs = settings.dangerZoneHours * 60 * 60 * 1000;

      const overdue = incompleteTasks.filter(t => t.deadline && new Date(t.deadline) < now);
      const urgent = incompleteTasks.filter(t => t.deadline && !overdue.includes(t) && (new Date(t.deadline) - now) < dangerMs);
      const quickWins = incompleteTasks.filter(t => t.effort === 'quick' && !overdue.includes(t) && !urgent.includes(t));

      const weekend = isWeekend(selectedDate);
      const availStartHour = weekend ? settings.weekendAvailableAfter : settings.weekdayAvailableAfter;
      const availEndHour = weekend ? settings.weekendAvailableUntil : settings.weekdayAvailableUntil;
      // Show full 24-hour day
      const displayStartHour = 0;
      const displayEndHour = 24;
      const hours = Array.from({ length: displayEndHour - displayStartHour }, (_, i) => displayStartHour + i);

      return (
        <div className="space-y-6 fade-in">
          {/* Alerts */}
          {overdue.length > 0 && (
            <div className="bg-red-50 border border-red-200 rounded-xl p-4">
              <h3 className="text-sm font-semibold text-red-700 mb-2">Overdue ({overdue.length})</h3>
              <div className="space-y-2">
                {overdue.map(t => <MiniTaskCard key={t.id} task={t} toggleDone={toggleDone} onEdit={onEdit} />)}
              </div>
            </div>
          )}

          {urgent.length > 0 && (
            <div className="bg-amber-50 border border-amber-200 rounded-xl p-4">
              <h3 className="text-sm font-semibold text-amber-700 mb-2">Due Soon ({urgent.length})</h3>
              <div className="space-y-2">
                {urgent.map(t => <MiniTaskCard key={t.id} task={t} toggleDone={toggleDone} onEdit={onEdit} />)}
              </div>
            </div>
          )}

          {/* Quick Wins */}
          {quickWins.length > 0 && !schedule && (
            <div className="bg-blue-50 border border-blue-200 rounded-xl p-4">
              <h3 className="text-sm font-semibold text-blue-700 mb-2">Quick Wins ({quickWins.length})</h3>
              <div className="space-y-2">
                {quickWins.slice(0, 5).map(t => <MiniTaskCard key={t.id} task={t} toggleDone={toggleDone} onEdit={onEdit} />)}
              </div>
            </div>
          )}

          {/* Timeline */}
          <div className="bg-white rounded-xl border border-gray-200 overflow-hidden">
            <div className="px-4 py-3 border-b border-gray-100 flex items-center justify-between">
              <h3 className="text-sm font-semibold text-gray-700">
                {schedule ? 'Scheduled Plan' : 'Timeline'}
              </h3>
              {!schedule && <span className="text-xs text-gray-400">Click "Plan My Day" to auto-schedule</span>}
            </div>
            <div className="timeline-grid">
              {hours.map(hour => {
                const blocksThisHour = schedule?.scheduled.filter(s =>
                  s.startMinutes < timeToMinutes(hour + 1) && s.endMinutes > timeToMinutes(hour)
                ) || [];

                const eventsThisHour = calendarEvents.filter(e => {
                  if (e.allDay) return false;
                  const es = new Date(e.start);
                  if (es.toDateString() !== new Date(selectedDate).toDateString()) return false;
                  const eStart = timeToMinutes(es.getHours(), es.getMinutes());
                  const eEnd = timeToMinutes(new Date(e.end).getHours(), new Date(e.end).getMinutes());
                  return eStart < timeToMinutes(hour + 1) && eEnd > timeToMinutes(hour);
                });

                const displayBlocks = schedule ? blocksThisHour : eventsThisHour.map(e => ({
                  id: e.id,
                  title: e.title,
                  type: 'event',
                  classification: eventClassifications[e.id] || eventClassifications[e.title?.toLowerCase()] || 'hard',
                  startMinutes: timeToMinutes(new Date(e.start).getHours(), new Date(e.start).getMinutes()),
                  endMinutes: timeToMinutes(new Date(e.end).getHours(), new Date(e.end).getMinutes()),
                }));

                const isAvailableHour = hour >= availStartHour && hour < availEndHour;

                return (
                  <React.Fragment key={hour}>
                    <div className={`time-slot px-2 py-2 text-xs text-right font-medium ${isAvailableHour ? 'text-violet-400' : 'text-gray-300'}`}>
                      {fmt.timeShort(hour)}
                    </div>
                    <div className={`time-slot px-2 py-1 relative ${!isAvailableHour ? 'bg-gray-50/50' : ''}`}>
                      {displayBlocks.filter(b => {
                        const blockStartHour = Math.floor(b.startMinutes / 60);
                        return blockStartHour === hour || (b.startMinutes < timeToMinutes(hour) && hour === displayStartHour);
                      }).map(block => {
                        if (block.type === 'event') {
                          const cls = block.classification;
                          const bgColor = cls === 'soft' ? 'bg-gray-100 border-gray-300 text-gray-600' : cls === 'academic' ? 'bg-violet-100 border-violet-300 text-violet-700' : 'bg-blue-100 border-blue-300 text-blue-700';
                          return (
                            <div key={block.id} className={`${bgColor} border rounded-md px-2 py-1 text-xs font-medium mb-1`}>
                              {block.title}
                              {cls === 'soft' && <span className="ml-1 opacity-60">(available)</span>}
                            </div>
                          );
                        }
                        if (block.type === 'task' || block.type === 'soft-suggestion') {
                          const cat = CATEGORIES[block.task.category];
                          const dur = block.endMinutes - block.startMinutes;
                          return (
                            <div key={block.id}
                              className="rounded-md px-2 py-1.5 text-xs font-medium mb-1 flex items-center gap-2 cursor-pointer hover:opacity-80"
                              style={{ backgroundColor: cat.light, borderLeft: `3px solid ${cat.color}` }}
                              onClick={() => onEdit(block.task)}>
                              <span className="truncate">{block.task.title}</span>
                              <span className="text-[10px] opacity-60 flex-shrink-0">{dur}m</span>
                              {block.type === 'soft-suggestion' && <span className="text-[10px] opacity-50">ðŸ’¡</span>}
                            </div>
                          );
                        }
                        return null;
                      })}
                    </div>
                  </React.Fragment>
                );
              })}
            </div>
          </div>

          {/* Unscheduled tasks */}
          {schedule && (() => {
            const scheduledIds = new Set(schedule.scheduled.filter(s => s.taskId).map(s => s.taskId));
            const unscheduled = incompleteTasks.filter(t => !scheduledIds.has(t.id));
            if (unscheduled.length === 0) return null;
            return (
              <div className="bg-gray-50 rounded-xl border border-gray-200 p-4">
                <h3 className="text-sm font-semibold text-gray-600 mb-2">Couldn't fit today ({unscheduled.length})</h3>
                <div className="space-y-2">
                  {unscheduled.slice(0, 8).map(t => <MiniTaskCard key={t.id} task={t} toggleDone={toggleDone} onEdit={onEdit} />)}
                </div>
              </div>
            );
          })()}
        </div>
      );
    }

    // ===== WEEK VIEW =====
    function WeekView({ tasks, calendarEvents, selectedDate, settings, eventClassifications, toggleDone, onEdit }) {
      const weekStart = new Date(selectedDate);
      const day = weekStart.getDay();
      weekStart.setDate(weekStart.getDate() - (day === 0 ? 6 : day - 1)); // Monday

      const days = Array.from({ length: 7 }, (_, i) => {
        const d = new Date(weekStart);
        d.setDate(d.getDate() + i);
        return d;
      });

      const incompleteTasks = tasks.filter(t => t.status !== 'done');

      return (
        <div className="fade-in">
          <div className="grid grid-cols-1 md:grid-cols-7 gap-3">
            {days.map(d => {
              const dateStr = d.toISOString().split('T')[0];
              const isToday = dateStr === new Date().toISOString().split('T')[0];
              const dayEvents = calendarEvents.filter(e => {
                const es = new Date(e.start);
                return es.toDateString() === d.toDateString() && !e.allDay;
              });
              const dayTasks = incompleteTasks.filter(t => t.deadline && new Date(t.deadline).toDateString() === d.toDateString());

              return (
                <div key={dateStr} className={`bg-white rounded-xl border p-3 ${isToday ? 'border-violet-300 ring-1 ring-violet-100' : 'border-gray-200'}`}>
                  <div className={`text-xs font-semibold mb-2 ${isToday ? 'text-violet-600' : 'text-gray-500'}`}>
                    {d.toLocaleDateString('en-US', { weekday: 'short', day: 'numeric' })}
                  </div>
                  <div className="space-y-1">
                    {dayEvents.slice(0, 4).map(e => (
                      <div key={e.id} className="text-[11px] bg-blue-50 text-blue-700 rounded px-1.5 py-0.5 truncate">
                        {fmt.time(e.start)} {e.title}
                      </div>
                    ))}
                    {dayTasks.map(t => (
                      <div key={t.id} className="text-[11px] rounded px-1.5 py-0.5 truncate cursor-pointer hover:opacity-80"
                        style={{ backgroundColor: CATEGORIES[t.category].light, color: CATEGORIES[t.category].color }}
                        onClick={() => onEdit(t)}>
                        {EFFORT[t.effort].icon} {t.title}
                      </div>
                    ))}
                    {dayEvents.length === 0 && dayTasks.length === 0 && (
                      <div className="text-[11px] text-gray-300 italic">No events</div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          {/* Tasks without deadlines */}
          <div className="mt-6 bg-white rounded-xl border border-gray-200 p-4">
            <h3 className="text-sm font-semibold text-gray-700 mb-3">Backlog (no deadline)</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
              {incompleteTasks.filter(t => !t.deadline).map(t => (
                <MiniTaskCard key={t.id} task={t} toggleDone={toggleDone} onEdit={onEdit} />
              ))}
              {incompleteTasks.filter(t => !t.deadline).length === 0 && (
                <div className="text-sm text-gray-400">No backlog tasks</div>
              )}
            </div>
          </div>
        </div>
      );
    }

    // ===== ALL TASKS VIEW =====
    function AllTasksView({ tasks, toggleDone, deleteTask, onEdit }) {
      const [filter, setFilter] = useState('all');
      const [statusFilter, setStatusFilter] = useState('active');
      const [sortBy, setSortBy] = useState('created');

      let filtered = tasks;
      if (filter !== 'all') filtered = filtered.filter(t => t.category === filter);
      if (statusFilter === 'active') filtered = filtered.filter(t => t.status !== 'done');
      else if (statusFilter === 'done') filtered = filtered.filter(t => t.status === 'done');

      if (sortBy === 'deadline') filtered = [...filtered].sort((a, b) => {
        if (!a.deadline) return 1; if (!b.deadline) return -1;
        return new Date(a.deadline) - new Date(b.deadline);
      });
      else if (sortBy === 'importance') filtered = [...filtered].sort((a, b) => b.importance - a.importance);
      else filtered = [...filtered].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      return (
        <div className="fade-in space-y-4">
          {/* Filters */}
          <div className="flex flex-wrap gap-2">
            <div className="flex bg-white rounded-lg border border-gray-200 p-0.5">
              {['all', ...Object.keys(CATEGORIES)].map(c => (
                <button key={c} onClick={() => setFilter(c)}
                  className={`px-3 py-1 text-xs font-medium rounded-md transition-colors ${filter === c ? 'bg-gray-900 text-white' : 'text-gray-500 hover:text-gray-700'}`}>
                  {c === 'all' ? 'All' : CATEGORIES[c].label}
                </button>
              ))}
            </div>
            <div className="flex bg-white rounded-lg border border-gray-200 p-0.5">
              {[['active', 'Active'], ['done', 'Done'], ['all', 'All']].map(([k, l]) => (
                <button key={k} onClick={() => setStatusFilter(k)}
                  className={`px-3 py-1 text-xs font-medium rounded-md transition-colors ${statusFilter === k ? 'bg-gray-900 text-white' : 'text-gray-500 hover:text-gray-700'}`}>
                  {l}
                </button>
              ))}
            </div>
            <select value={sortBy} onChange={e => setSortBy(e.target.value)}
              className="px-3 py-1 text-xs font-medium bg-white border border-gray-200 rounded-lg text-gray-600">
              <option value="created">Newest first</option>
              <option value="deadline">By deadline</option>
              <option value="importance">By importance</option>
            </select>
          </div>

          {/* Task list */}
          <div className="space-y-2">
            {filtered.map(t => (
              <TaskCard key={t.id} task={t} toggleDone={toggleDone} deleteTask={deleteTask} onEdit={onEdit} />
            ))}
            {filtered.length === 0 && (
              <div className="text-center py-12 text-gray-400">
                <div className="text-4xl mb-2">âœ¨</div>
                <div className="text-sm">No tasks here. Add one to get started!</div>
              </div>
            )}
          </div>
        </div>
      );
    }

    // ===== SETTINGS VIEW =====
    function SettingsView({ settings, setSettings, gcalConnected, connectGCal, gcalLoading, calendarEvents, eventClassifications, setEventClassifications }) {
      const update = (key, value) => setSettings(prev => ({ ...prev, [key]: value }));

      const uniqueEvents = useMemo(() => {
        const seen = new Set();
        return calendarEvents.filter(e => {
          if (seen.has(e.title)) return false;
          seen.add(e.title);
          return true;
        });
      }, [calendarEvents]);

      return (
        <div className="fade-in space-y-6 max-w-2xl">
          {/* Google Calendar */}
          <section className="bg-white rounded-xl border border-gray-200 p-5">
            <h3 className="text-sm font-semibold text-gray-800 mb-4">Google Calendar</h3>
            {gcalConnected ? (
              <div className="flex items-center gap-2 text-sm text-emerald-600 font-medium">
                <span className="w-2 h-2 bg-emerald-500 rounded-full" /> Connected
              </div>
            ) : (
              <div className="space-y-3">
                <div>
                  <label className="block text-xs font-medium text-gray-600 mb-1">Google Client ID</label>
                  <input type="text" value={settings.googleClientId} onChange={e => update('googleClientId', e.target.value)}
                    placeholder="your-id.apps.googleusercontent.com"
                    className="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-violet-500" />
                </div>
                <button onClick={connectGCal} disabled={!settings.googleClientId || gcalLoading}
                  className="px-4 py-2 text-sm font-medium bg-violet-600 text-white rounded-lg hover:bg-violet-700 disabled:opacity-50">
                  {gcalLoading ? 'Connecting...' : 'Connect Google Calendar'}
                </button>
                <details className="text-xs text-gray-500">
                  <summary className="cursor-pointer hover:text-gray-700 font-medium">Setup instructions</summary>
                  <ol className="mt-2 space-y-1 list-decimal list-inside">
                    <li>Go to <strong>console.cloud.google.com</strong></li>
                    <li>Create a new project (or select existing)</li>
                    <li>Enable the <strong>Google Calendar API</strong></li>
                    <li>Configure the <strong>OAuth consent screen</strong> (External, add your email as test user)</li>
                    <li>Go to Credentials â†’ Create <strong>OAuth 2.0 Client ID</strong></li>
                    <li>Application type: <strong>Web application</strong></li>
                    <li>Add authorized JavaScript origin: <strong>https://YOUR_USERNAME.github.io</strong></li>
                    <li>Copy the Client ID and paste above</li>
                  </ol>
                  <p className="mt-2 text-gray-400">If running locally, also add <strong>http://localhost:8000</strong> as an origin.</p>
                </details>
              </div>
            )}
          </section>

          {/* Access Control */}
          <section className="bg-white rounded-xl border border-gray-200 p-5">
            <h3 className="text-sm font-semibold text-gray-800 mb-1">Access Control</h3>
            <p className="text-xs text-gray-500 mb-3">Only these Google accounts can sign in. Requires a Client ID above.</p>
            <div className="space-y-2">
              {(settings.allowedEmails || []).map((email, i) => (
                <div key={i} className="flex items-center gap-2">
                  <input type="email" value={email} onChange={e => {
                    const updated = [...(settings.allowedEmails || [])];
                    updated[i] = e.target.value;
                    update('allowedEmails', updated);
                  }} className="flex-1 px-3 py-1.5 text-sm border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-violet-500" />
                  <button onClick={() => {
                    const updated = (settings.allowedEmails || []).filter((_, j) => j !== i);
                    update('allowedEmails', updated);
                  }} className="text-gray-300 hover:text-red-400 p-1">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M3 3l8 8M11 3l-8 8" stroke="currentColor" strokeWidth="1.5"/></svg>
                  </button>
                </div>
              ))}
              <button onClick={() => update('allowedEmails', [...(settings.allowedEmails || []), ''])}
                className="text-xs text-violet-600 hover:text-violet-700 font-medium">+ Add email</button>
            </div>
          </section>

          {/* Event Classifications */}
          {uniqueEvents.length > 0 && (
            <section className="bg-white rounded-xl border border-gray-200 p-5">
              <h3 className="text-sm font-semibold text-gray-800 mb-1">Event Classifications</h3>
              <p className="text-xs text-gray-500 mb-4">Tell Focus which events are real commitments vs. flexible time.</p>
              <div className="space-y-2">
                {uniqueEvents.map(e => {
                  const cls = eventClassifications[e.id] || eventClassifications[e.title?.toLowerCase()] || 'hard';
                  return (
                    <div key={e.id} className="flex items-center justify-between gap-3 py-2 border-b border-gray-50 last:border-0">
                      <span className="text-sm text-gray-700 truncate flex-1">{e.title}</span>
                      <select value={cls} onChange={ev => {
                        setEventClassifications(prev => ({ ...prev, [e.id]: ev.target.value, [e.title.toLowerCase()]: ev.target.value }));
                      }} className="px-2 py-1 text-xs border border-gray-200 rounded-lg bg-white">
                        <option value="hard">Hard block</option>
                        <option value="soft">Soft (available)</option>
                        <option value="academic">Academic time</option>
                      </select>
                    </div>
                  );
                })}
              </div>
            </section>
          )}

          {/* Schedule Preferences */}
          <section className="bg-white rounded-xl border border-gray-200 p-5">
            <h3 className="text-sm font-semibold text-gray-800 mb-4">Schedule Preferences</h3>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Weekday available after</label>
                <select value={settings.weekdayAvailableAfter} onChange={e => update('weekdayAvailableAfter', Number(e.target.value))}
                  className="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg">
                  {Array.from({ length: 12 }, (_, i) => i + 12).map(h => (
                    <option key={h} value={h}>{fmt.timeShort(h)}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Weekday available until</label>
                <select value={settings.weekdayAvailableUntil} onChange={e => update('weekdayAvailableUntil', Number(e.target.value))}
                  className="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg">
                  {Array.from({ length: 8 }, (_, i) => i + 17).map(h => (
                    <option key={h} value={h}>{fmt.timeShort(h)}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Weekend available after</label>
                <select value={settings.weekendAvailableAfter} onChange={e => update('weekendAvailableAfter', Number(e.target.value))}
                  className="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg">
                  {Array.from({ length: 10 }, (_, i) => i + 7).map(h => (
                    <option key={h} value={h}>{fmt.timeShort(h)}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Weekend available until</label>
                <select value={settings.weekendAvailableUntil} onChange={e => update('weekendAvailableUntil', Number(e.target.value))}
                  className="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg">
                  {Array.from({ length: 8 }, (_, i) => i + 17).map(h => (
                    <option key={h} value={h}>{fmt.timeShort(h)}</option>
                  ))}
                </select>
              </div>
              <div className="col-span-2">
                <label className="block text-xs font-medium text-gray-600 mb-1">Deadline danger zone (hours)</label>
                <input type="number" value={settings.dangerZoneHours} onChange={e => update('dangerZoneHours', Number(e.target.value))}
                  className="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg" min="1" max="168" />
                <p className="text-xs text-gray-400 mt-1">Tasks due within this window get top priority</p>
              </div>
            </div>
          </section>

          {/* Data */}
          <section className="bg-white rounded-xl border border-gray-200 p-5">
            <h3 className="text-sm font-semibold text-gray-800 mb-4">Data</h3>
            <div className="flex gap-2">
              <button onClick={() => {
                const data = JSON.stringify({ tasks: storage.get('tasks', []), settings: storage.get('settings', DEFAULT_SETTINGS), eventClassifications: storage.get('eventClassifications', {}) }, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'focus-backup.json'; a.click();
              }} className="px-3 py-1.5 text-sm font-medium border border-gray-200 rounded-lg hover:bg-gray-50">
                Export backup
              </button>
              <label className="px-3 py-1.5 text-sm font-medium border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                Import backup
                <input type="file" accept=".json" className="hidden" onChange={(e) => {
                  const f = e.target.files[0]; if (!f) return;
                  const r = new FileReader();
                  r.onload = (ev) => {
                    try {
                      const data = JSON.parse(ev.target.result);
                      if (data.tasks) storage.set('tasks', data.tasks);
                      if (data.settings) storage.set('settings', data.settings);
                      if (data.eventClassifications) storage.set('eventClassifications', data.eventClassifications);
                      window.location.reload();
                    } catch { alert('Invalid backup file'); }
                  };
                  r.readAsText(f);
                }} />
              </label>
            </div>
          </section>
        </div>
      );
    }

    // ===== TASK MODAL =====
    function TaskModal({ task, onSave, onClose }) {
      const [title, setTitle] = useState(task?.title || '');
      const [notes, setNotes] = useState(task?.notes || '');
      const [category, setCategory] = useState(task?.category || 'research');
      const [effort, setEffort] = useState(task?.effort || 'medium');
      const [importance, setImportance] = useState(task?.importance || 2);
      const [hasDeadline, setHasDeadline] = useState(!!task?.deadline);
      const [deadline, setDeadline] = useState(task?.deadline ? new Date(task.deadline).toISOString().slice(0, 16) : '');

      const handleSubmit = (e) => {
        e.preventDefault();
        if (!title.trim()) return;
        onSave({ title: title.trim(), notes, category, effort, importance, deadline: hasDeadline && deadline ? new Date(deadline).toISOString() : null });
      };

      return (
        <div className="fixed inset-0 bg-black/40 modal-overlay flex items-center justify-center z-50 p-4" onClick={onClose}>
          <form onSubmit={handleSubmit} onClick={e => e.stopPropagation()}
            className="bg-white rounded-2xl shadow-xl w-full max-w-md fade-in overflow-hidden">
            <div className="px-5 pt-5 pb-3">
              <h3 className="text-base font-semibold text-gray-900 mb-4">{task ? 'Edit Task' : 'New Task'}</h3>

              <input type="text" value={title} onChange={e => setTitle(e.target.value)} placeholder="Task title"
                autoFocus className="w-full text-lg font-medium text-gray-900 placeholder-gray-300 outline-none mb-3" />

              <textarea value={notes} onChange={e => setNotes(e.target.value)} placeholder="Notes (optional)"
                rows={2} className="w-full text-sm text-gray-600 placeholder-gray-300 outline-none resize-none mb-4 bg-gray-50 rounded-lg p-2" />

              {/* Category */}
              <div className="mb-4">
                <label className="block text-xs font-medium text-gray-500 mb-2">Category</label>
                <div className="flex gap-2">
                  {Object.entries(CATEGORIES).map(([key, cat]) => (
                    <button key={key} type="button" onClick={() => setCategory(key)}
                      className={`flex-1 px-2 py-1.5 text-xs font-medium rounded-lg border-2 transition-colors ${category === key ? 'border-current' : 'border-transparent bg-gray-50'}`}
                      style={category === key ? { backgroundColor: cat.light, color: cat.color, borderColor: cat.color } : {}}>
                      {cat.label}
                    </button>
                  ))}
                </div>
              </div>

              {/* Effort */}
              <div className="mb-4">
                <label className="block text-xs font-medium text-gray-500 mb-2">Effort</label>
                <div className="flex gap-2">
                  {Object.entries(EFFORT).map(([key, e]) => (
                    <button key={key} type="button" onClick={() => setEffort(key)}
                      className={`flex-1 px-2 py-1.5 text-xs font-medium rounded-lg transition-colors ${effort === key ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-600 hover:bg-gray-100'}`}>
                      {e.icon} {e.label} <span className="opacity-60">({e.minutes}m)</span>
                    </button>
                  ))}
                </div>
              </div>

              {/* Importance */}
              <div className="mb-4">
                <label className="block text-xs font-medium text-gray-500 mb-2">Importance</label>
                <div className="flex gap-1">
                  {[1, 2, 3].map(v => (
                    <button key={v} type="button" onClick={() => setImportance(v)}
                      className={`px-3 py-1 text-sm rounded-lg transition-colors ${importance >= v ? 'text-amber-500' : 'text-gray-300'}`}>
                      â˜…
                    </button>
                  ))}
                  <span className="text-xs text-gray-400 ml-2 self-center">
                    {importance === 1 ? 'Low' : importance === 2 ? 'Medium' : 'High'}
                  </span>
                </div>
              </div>

              {/* Deadline */}
              <div className="mb-2">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input type="checkbox" checked={hasDeadline} onChange={e => setHasDeadline(e.target.checked)}
                    className="rounded border-gray-300 text-violet-600 focus:ring-violet-500" />
                  <span className="text-xs font-medium text-gray-500">Has deadline</span>
                </label>
                {hasDeadline && (
                  <input type="datetime-local" value={deadline} onChange={e => setDeadline(e.target.value)}
                    className="mt-2 w-full px-3 py-2 text-sm border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-violet-500" />
                )}
              </div>
            </div>

            <div className="px-5 py-3 bg-gray-50 flex justify-end gap-2">
              <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-600 hover:bg-gray-100 rounded-lg">Cancel</button>
              <button type="submit" className="px-4 py-2 text-sm font-medium bg-violet-600 text-white rounded-lg hover:bg-violet-700">
                {task ? 'Save' : 'Add Task'}
              </button>
            </div>
          </form>
        </div>
      );
    }

    // ===== TASK CARD =====
    function TaskCard({ task, toggleDone, deleteTask, onEdit }) {
      const cat = CATEGORIES[task.category];
      const eff = EFFORT[task.effort];
      const isDone = task.status === 'done';

      return (
        <div className={`task-card bg-white rounded-xl border border-gray-200 p-4 flex items-start gap-3 ${isDone ? 'opacity-60' : ''}`}>
          <button onClick={() => toggleDone(task.id)}
            className={`mt-0.5 w-5 h-5 rounded-full border-2 flex-shrink-0 flex items-center justify-center transition-colors ${isDone ? 'bg-violet-500 border-violet-500 text-white' : 'border-gray-300 hover:border-violet-400'}`}>
            {isDone && <svg width="10" height="10" viewBox="0 0 10 10"><path d="M2 5l2 2 4-4" stroke="currentColor" strokeWidth="2" fill="none"/></svg>}
          </button>
          <div className="flex-1 min-w-0 cursor-pointer" onClick={() => onEdit(task)}>
            <div className="flex items-center gap-2 mb-1">
              <div className="category-dot" style={{ backgroundColor: cat.color }} />
              <span className={`text-sm font-medium ${isDone ? 'line-through text-gray-400' : 'text-gray-900'}`}>{task.title}</span>
            </div>
            <div className="flex items-center gap-2 text-xs text-gray-400">
              <span style={{ color: cat.color }}>{cat.label}</span>
              <span>Â·</span>
              <span>{eff.icon} {eff.label}</span>
              {task.deadline && (
                <>
                  <span>Â·</span>
                  <span className={new Date(task.deadline) < new Date() && !isDone ? 'text-red-500 font-medium' : ''}>
                    {fmt.relative(task.deadline)}
                  </span>
                </>
              )}
              <span>Â·</span>
              <span className="text-amber-400">{'â˜…'.repeat(task.importance)}{'â˜†'.repeat(3 - task.importance)}</span>
            </div>
            {task.notes && <p className="text-xs text-gray-400 mt-1 truncate">{task.notes}</p>}
          </div>
          <button onClick={() => deleteTask(task.id)}
            className="text-gray-300 hover:text-red-400 transition-colors flex-shrink-0 p-1">
            <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M3 3l8 8M11 3l-8 8" stroke="currentColor" strokeWidth="1.5"/></svg>
          </button>
        </div>
      );
    }

    // ===== MINI TASK CARD =====
    function MiniTaskCard({ task, toggleDone, onEdit }) {
      const cat = CATEGORIES[task.category];
      const eff = EFFORT[task.effort];

      return (
        <div className="flex items-center gap-2 group">
          <button onClick={() => toggleDone(task.id)}
            className="w-4 h-4 rounded-full border-2 border-gray-300 hover:border-violet-400 flex-shrink-0 transition-colors" />
          <div className="category-dot" style={{ backgroundColor: cat.color }} />
          <span className="text-sm text-gray-800 truncate flex-1 cursor-pointer hover:text-violet-600" onClick={() => onEdit(task)}>
            {task.title}
          </span>
          <span className="text-[11px] text-gray-400">{eff.icon}</span>
          {task.deadline && <span className="text-[11px] text-gray-400">{fmt.relative(task.deadline)}</span>}
        </div>
      );
    }

    // ===== RENDER =====
    ReactDOM.createRoot(document.getElementById('root')).render(<AuthGate><App /></AuthGate>);
  </script>
</body>
</html>
